# KEEP IN ALPHABETIC ORDER
global !p
from snippet_utils import preceeding_lines, top_level, find_line, find_lines
from go_snippet_utils import import_re, add_import

type_re = re.compile(r"^type (\w+)")
struct_re = re.compile(r"^type (\w+) struct")
method_re = re.compile(r"^func \(([^)]+)\)\s+(\w+)\(")
func_re = re.compile(r"^func (\w+)\(")
test_re = re.compile(r"^func Test([^)]*)\(")
ws_re = re.compile(r'\s+')


convert_type_map = {
	'i':   'int',
	'i1':  'int16',
	'i3':  'int32',
	'i6':  'int64',
	'ui1': 'uint16',
	'ui3': 'uint32',
	'ui6': 'uint64',

	's': 'string',

	'f': 'float',
	'f3': 'float32',
	'f6': 'float64',

	'b': 'byte',
	'd': 'byte', # Convenience alias

	'B': 'bool',

	'r': 'rune',
}

simple_value_map = {
	'n': 'nil',
	't': 'true',
	'f': 'false',
}

def find_method_type(pointer=False):
	for line in preceeding_lines():
		match = method_re.match(line)

		if match:
			rec_name, _, rec_type = match[1].partition(' ')

			if pointer and '*' not in rec_type:
				rec_type = '*' + rec_type

			return (rec_name, rec_type)

		match = type_re.match(line)

		if match:
			name = match[1]
			rec_type = name

			if pointer:
				rec_type = '*' + rec_type

			rec_name = (name[0] + re.sub('[a-z]', '', name[1:])).lower()

			return (rec_name, rec_type)

	return ('', 'nil')


def find_type():
	for line in preceeding_lines():
		match = type_re.match(line)

		if match:
			return match[1]

	return ''


def get_receiver_type():
	no_leading_whitespace_re = re.compile('^[^\s]')

	for line in preceeding_lines():
		match = no_leading_whitespace_re.match(line)

		if match:
			# Found the line before this line that doesn't have any leading whitespace,
			# possibly the method declaration
			match = method_re.match(line)

			if match:
				return match[1]
			else:
				# In this case, either we're in a regular function or not in any function at all
				return ''

def get_receiver_name():
	return get_receiver_type().split(' ')[0]

def guess_log_var():
	receiver_type = get_receiver_type()

	if receiver_type:
		return f"{receiver_type.split(' ')[0]}.log"

	return 'log'


def guess_test_name():
	# NOTE: It is VERY important that this function ALWAYS returns a non-empty
	# string, so that the snippet pluging doesn't run this function more than
	# once per template

	reg = vim.eval('@"')

	match = method_re.match(reg)

	if match:
		vim.command('let @" = ""')
		type_name = match[1].split(' ')[1]

		if type_name.startswith('*'):
			type_name = type_name[1:]

		return f'_{type_name}_{match[2]}_'

	match = func_re.match(reg)

	if match and not match[1].startswith('Test'):
		vim.command('let @" = ""')
		return f'_{match[1]}_'

	for line in preceeding_lines():
		match = test_re.match(line)

		if match:
			parts = [part for part in match[1].split('_') if len(part) > 0]

			if len(parts) > 1:
				# All but the last item
				return '_' + '_'.join(parts[:-1]) + '_'
			else:
				break

	return '_'

def get_package_name():
	return vim.current.window.buffer[0].split(' ')[1]

def get_interface_type(name):
	if '.' in name:
		return name

	return f'{get_package_name()}.{name}'

def implement_interface():
	interface = get_interface_type(match[1])
	method_type = find_method_type(True)
	vim.command(f'GoImpl {" ".join(method_type)} {interface}')

	# Part of the reason this function returns a comment is so that the snippet
	# doesn't run this function multiple times
	return f'// {method_type[1]} implements {interface}'

def get_function_name():
	for line in preceeding_lines():
		match = func_re.match(line)

		if match:
			return match[1]

		match = method_re.match(line)

		if match:
			return match[2]

	return ''

def previous_test_name():
	for line in preceeding_lines():
		match = test_re.match(line)

		if match:
			return match[1]

	return ''




# ends_with_non_letter = re.compile(r'[^a-zA-Z]$')
non_alphanum_underscore = re.compile(r'[^a-zA-Z0-9_]')

def capitalise(s, remove=None, cap_first=False):
	cap = cap_first

	for i in range(len(s)):
		if s[i].isalpha():
			if cap:
				s = s[:i] + s[i].upper() + s[i+1:]
			cap = False
		else:
			cap = True

	if remove is not None:
		s = remove.sub('', s)

	return s

def smart_capitalisation(s, cap_first=True):
	# Detects if the name has been dictated, and formats if necessary

	if ' ' in s:
		# Default to public methods
		return capitalise(s, non_alphanum_underscore, cap_first)

	return s

def start_dictation(ret_val):
	vim.command('call dictate#Start()')
	# Returning a value prevents the function for being run multiple times
	# during a single expansion of a snippet
	return ret_val

def to_comparison(snip_str):
	lg, e = snip_str

	sym = '>'

	if lg == 'l':
		sym = '<'

	if e == 'e':
		sym += '='

	return sym

def auto_expand_cond(snip):
	return re.match(r'^\t+if ', snip.buffer[snip.line])

def is_only_line_contents(s, snip):
	return snip.buffer[snip.line].strip() == s.strip()

def generate_mock(interface):
	interface_name = get_interface_name(interface)
	interface_type = get_interface_type(interface)
	vim.command(f'GoImpl m *Mock{interface_name} {interface_type}')

	vim.current.window.buffer.append([
		f'func NewMock{interface_name}(t *testing.T) *Mock{interface_name} ' + '{',
		f'\treturn &Mock{interface_name}' + '{',
		'\t\tt: t,',
		'\t}',
		'}',
		'',
	], vim.current.window.cursor[0] + 3)

	fields = []

	for (linenr, line) in find_lines(re.compile(r'panic\("not implemented"\)')):
		method = next(top_level(preceeding_lines(linenr)))

		match = method_re.match(method)

		if not match:
			continue

		del vim.current.window.buffer[linenr]

		method_name = match[2]

		s = method[len(match[0]):]

		method_sig = re.sub(r'\s*{\s*$', '', s)

		func_type = f'func({method_sig}'

		args, s = read_args(s)
		ret_vals = read_return(s)

		mock_method_name = f'{method_name}_Mock'

		fields.append(f'\t{mock_method_name} {func_type}')

		ret_statement = ''

		if len(ret_vals) > 0:
			ret_statement = 'return '

		func_call = f'\t{ret_statement}m.{method_name}_Mock(' + ', '.join(arg_name for (arg_name, _) in args) + ')'

		err_msg = f'"{interface_name}.{method_name}() should not have been called"'

		vim.current.window.buffer.append([
			f'\tif m.{mock_method_name} == nil ' + '{',
			f'\t\tm.t.Error({err_msg})',
			'\t\tm.t.FailNow()',
			# f'\t\tpanic({err_msg})',
			'\t}',
			'',
			func_call
		], linenr)

	fields_str = "\n".join(fields).strip()

	if fields_str:
		fields_str = '\n\t' + fields_str

	return f't *testing.T{fields_str}'


def get_interface_name(interface):
	parts = interface.split('.')

	if len(parts) == 1:
		return parts[0]
	else:
		return parts[1]


def read_args(s):
	args_str, rest = read_parens(s)

	args = []

	for arg in args_str.split(','):
		arg = arg.strip()

		if arg == '':
			continue

		parts = ws_re.split(arg, maxsplit=1)

		if len(parts) == 1:
			args.append(('', parts[0]))
		else:
			args.append((parts[0], parts[1]))

	return args, rest


def read_return(s):
	s = s.strip()

	if s.startswith('('):
		ret = []

		ret_str, _ = read_parens(s[1:])

		for ret_val in ret_str.split(','):
			parts = ws_re.split(ret_val.strip(), maxsplit=1)

			if len(parts) == 1:
				ret.append(('', parts[0]))
			else:
				ret.append((parts[0], parts[1]))

		return ret

	ret_type = re.sub(r'\s*{\s*$', '', s).strip()

	if ret_type == '':
		return []

	return [('', ret_type)]


def read_parens(s):
	depth = 1

	for (i, c) in enumerate(s):
		if c == '(':
			depth += 1
		elif c == ')':
			depth -= 1

		if depth == 0:
			return s[:i], s[i+1:]

	return s, ''


def get_mock_signature(snip):
	line = snip.buffer[snip.line]

	match = re.search(r'(\.)?[A-Za-z0-9_]+_Mock(:)?$', line)

	if not match or (not match[1] and not match[2]):
		return False

	info = ""

	if line.endswith(':'):
		l, c = vim.current.window.cursor
		vim.current.window.cursor = (l, c - 1)
		info = vim.eval('go#lsp#GetInfo()')
		vim.current.window.cursor = (l, c)
	else:
		info = vim.eval('go#lsp#GetInfo()')

	print('Type:', info)

	if not re.match(r'^field [A-Za-z0-9_]+_Mock func', info):
		return False

	field, name, func_type = info.split(' ', maxsplit=2)
	vim.command(f"let b:__mock_type = '{func_type}'")

	return True
endglobal

## Auto-imports ##

context "add_import('errors.', snip, 'errors')"
snippet errors. "Errors auto-import" bwA
errors.
endsnippet

context "add_import('fmt.', snip, 'fmt')"
snippet fmt. "Format auto-import" bwA
fmt.
endsnippet

context "add_import('http.', snip, 'net/http')"
snippet http. "HTTP auto-import" bwA
http.
endsnippet

context "add_import('json.', snip, 'encoding/json')"
snippet json. "JSON auto-import" bwA
json.
endsnippet

context "add_import('os.', snip, 'os')"
snippet os. "OS auto-import" bwA
os.
endsnippet

## A ##

snippet 'as ' "Append to slice" brA
$1 = append($1, $0)
endsnippet

snippet 'Ae ' "Assert Equal" brA
assert.Equal(${1:expected}, ${2:actual})
endsnippet

snippet 'Af ' "Assert False" brA
assert.False(${1:actual})
endsnippet

snippet 'AFn ' "Assert Fail Now" brA
assert.FailNow("$1")
endsnippet

snippet 'Aem ' "Assert Equal with Message" brA
assert.Equal(${1:expected}, ${2:actual}, "${3:message}")
endsnippet

snippet 'Al ' "Assert Length" brA
assert.Len(${1:result}, ${2:length})
endsnippet

snippet 'Ane ' "Assert Not Equal" brA
assert.NotEqual(${1:expected}, ${2:actual})
endsnippet

snippet 'Anem ' "Assert Not Equal with Message" brA
assert.NotEqual(${1:expected}, ${2:actual}, "${3:message}")
endsnippet

snippet 'Aner ' "Assert No Error" brA
assert.NoError(${1:err})
endsnippet

snippet 'Anerm ' "Assert No Error with Message" brA
assert.NoError(${1:err}, "${2:message}")
endsnippet

snippet 'An ' "Assert Nil" brA
assert.Nil(${1:value})
endsnippet

snippet 'Anm ' "Assert Nil with Message" brA
assert.Nil(${1:value}, "${2:message}")
endsnippet

snippet 'Ann ' "Assert Not Nil" brA
assert.NotNil(${1:value})
endsnippet

snippet 'Annm ' "Assert Not Nil with Message" brA
assert.NotNil(${1:value}, "${2:message}")
endsnippet

snippet 'At ' "Assert True" brA
assert.True(${1:actual})
endsnippet

## C ##

snippet '^co$' "Const" brA
const $1 = `!p t[1] = smart_capitalisation(t[1])`
endsnippet

snippet c "Channel" bw
$1 := make(chan $2)
endsnippet

snippet cd "Channel with deferred close" bw
$1 := make(chan $2)
defer close($1)
endsnippet

snippet 'cc ' "Comment with dictation" brA
`!p snip.rv = snip.c or start_dictation('//')` $1
endsnippet

snippet '\bc(\[\])?(u?i[136]?|f[36]?|[sbBdr])\b' "Convert to Type" r
`!p snip.rv = match.group(1) or ''``!p snip.rv = convert_type_map[match.group(2)]`(${VISUAL}$1)
endsnippet

snippet '\bc\?\b' "Convert to Arbitrary Type" r
$1(${VISUAL}$2)
endsnippet

## D ##

snippet dc "Done Channel" bw
done := make(chan struct{})
defer close(done)
endsnippet

snippet '\bdd' "Data (Byte slice)" wr
[]byte
endsnippet

snippet '\bds' "Data string (Byte slice)" wr
[]byte("$1")
endsnippet

## E ##

snippet 'Ef' "Errorf" "add_import('Ef', snip, 'fmt')" re
fmt.Errorf("$1", $2)
endsnippet

snippet 'Eft' "Errorf with error template" "add_import('Eft', snip, 'fmt')" re
fmt.Errorf("$1: %s",$2 err)
endsnippet

snippet 'En' "errors.new" "add_import('En', snip, 'errors')" re
errors.New("$1")
endsnippet

## F ##

snippet 'F(\[\])?(u?i[136]?|f[36]?|s|b|B)' "Field" bwr
$1 `!p snip.rv = match[1] or ''``!p snip.rv = convert_type_map.get(match[2] or '', '')``!p t[1] = smart_capitalisation(t[1])`
endsnippet

snippet Fl "Field (logger)" "add_import('Fl', snip, 'github.com/rs/zerolog')" bwe
log zerolog.Logger
endsnippet

snippet FL "Field (Lock)" "add_import('FL', snip, 'sync')" bwe
${1:lock} sync.Mutex
endsnippet

snippet FLr "Field (RW Lock)" "add_import('FLr', snip, 'sync')" bwe
${1:lock} sync.RWMutex
endsnippet

snippet '^f ' "Function" brA
// $1 ${4:TODO: Description}.
func ${1: }($2)$3 {`!p t[1] = smart_capitalisation(t[1])`
	$0
}
endsnippet

snippet '(?<=.)\bf' "Anonymous Function" wr
func($1)$2 {
	$0
}
endsnippet

snippet '(?<=.)\bfr' "Anonymous Function with Return" wr
func($1) $2 {
	return $0
}
endsnippet

snippet '^fc ' "Function - Constructor" brA
func New$1($2) *$1 {
	return &${1:`!p if not snip.c: snip.rv = find_type() or 'Type'`}{
		$0
	}
}
endsnippet

snippet '^fcl ' "Function - Constructor with Log" "add_import('fcl', snip, 'github.com/rs/zerolog/log')" breA
func New$1($2) *$1 {
	return &${1:`!p if not snip.c: snip.rv = find_type() or 'Type'`}{
		$0
		log: log.With().
			Str("cls", "$1").
			Logger(),
	}
}
endsnippet

context "is_only_line_contents('for', snip)"
snippet 'for ' "For" breA
for $1`!p snip.rv = ' ' if len(t[1]) > 0 else ''`{
	$0
}
endsnippet

snippet 'forc ' "For channel" brA
for $1 := range $2 {
	$0
}
endsnippet

snippet 'fore ' "For each" brA
for ${1:_}, $2 := range $3 {
	$0
}
endsnippet

snippet 'fori ' "For counter (i)" brA
for i := ${1:0}; i < $2; i++ {
	$0
}
endsnippet

## G ##

snippet go "Goroutine of an anonymous function"
go func() {
	$0
}()
endsnippet

## I ##

# TODO: Consider unifying the "If" snippets

snippet '^ii ' "Implement Interface Template" brA
type impl $1
endsnippet

snippet 'ic ' "Improvement Comment" brA
// IMPROVEMENT: $0
endsnippet

snippet '^type impl ([^\s]+) ' "Implement Interface" brA
`!p snip.rv = snip.c or implement_interface()`
endsnippet

snippet 'if ' "If" brA
if $1 {
	$0
}
endsnippet

snippet '} ?e' "Else" brA
} else {
	$0
}
endsnippet

snippet '} ?i' "Else If" brA
} else if $1 {
	$0
}
endsnippet

snippet 'ifE ' "If error" brA
if err != nil {
	$0
}
endsnippet

snippet 'ifEr ' "If error, return" "add_import('ifEr ', snip, 'fmt')" breA
if err != nil {
	return $1fmt.Errorf("$2: %s",$3 err)
}
endsnippet

snippet ifEP "If error, panic" bA
if err != nil {
	panic(err)
}
endsnippet

snippet 'ifn ' "If nil" brA
if $1 == nil {
	$0
}
endsnippet

snippet 'ifnn ' "If not nil" brA
if $1 != nil {
	$0
}
endsnippet

snippet '\b([lg][et]) ' "Less/greater than" wrA
`!p snip.rv = snip.c or to_comparison(match[1])` ${0:0}
endsnippet

snippet '\bl([lg][et]) ' "Length less/greater than" wrA
len($1) `!p snip.rv = snip.c or to_comparison(match[1])` ${0:0}
endsnippet

snippet '\bl([ne])e ' "Length (not) equal" wrA
len($1) `!p snip.rv = '!' if match[1] == 'n' else '='`= ${0:0}
endsnippet

snippet 'ifv ' "If Validate" brA
if err := $1.Validate(); err != nil {
	$0
}
endsnippet

snippet 'ifvr ' "If Validate, return" brA
if err := $1.Validate(); err != nil {
	return $3fmt.Errorf("$4: %s",$5 err)
}
endsnippet

snippet 'ifs ' "If short" brA
if $1 := $2; $3 {
	$0
}
endsnippet

snippet 'ifsE ' "If short error" brA
if $1err := ${VISUAL:/^.*err :?= //}$2; err != nil {
	$0
}
endsnippet

snippet 'ifsEr ' "If short error, return" "add_import('isEr', snip, 'fmt')" breA
if $1err := ${VISUAL:/^.*err :?= //}$2; err != nil {
	return $3fmt.Errorf("$4: %s",$5 err)
}
endsnippet

snippet 'ifju ' "If Short JSON Unmarshal" "add_import('ifju ', snip, 'encoding/json')" breA
if err := json.Unmarshal(${1:data}, $2); err != nil {
	$0
}
endsnippet

snippet 'ifjur' "If Short JSON Unmarshal, return" "add_import('ifjur', snip, 'encoding/json', 'fmt')" breA
if err := json.Unmarshal(${1:data}, $2); err != nil {
	return $3fmt.Errorf("$4: %s",$5 err)
}
endsnippet

snippet '^im' "import" brA
import (
	$0
)
endsnippet

snippet '^in' "Interface" brA
// $1 ${2:TODO: Description}.
type ${1: } interface {
	$0
}
endsnippet

snippet '^\tim' "Interface Method" brA
	// $1 TODO: Description.
	${1: }($2)$0`!p t[1] = smart_capitalisation(t[1])`
endsnippet

## J ##

snippet jm "JSON Marshal" "add_import('jm', snip, 'encoding/json')" bwe
${1:data}, err := json.Marshal(${2:${VISUAL}})
endsnippet

snippet ju "JSON Unmarshal" "add_import('ju', snip, 'encoding/json')" bwe
err := json.Unmarshal(${1:data}, $2)
endsnippet

## L ##

snippet ld "Log Debug" bw
`!p snip.rv = guess_log_var()`.Debug().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msg("$1")
endsnippet

snippet ldf "Log Debug Format" bw
`!p snip.rv = guess_log_var()`.Debug().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msgf("$1", $2)
endsnippet

snippet li "Log Info" bw
`!p snip.rv = guess_log_var()`.Info().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msg("$1")
endsnippet

snippet lif "Log Info Format" bw
`!p snip.rv = guess_log_var()`.Info().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msgf("$1", $2)
endsnippet

snippet lw "Log Warn" bw
`!p snip.rv = guess_log_var()`.Warn().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msg("$1")
endsnippet

snippet lwf "Log Warn Format" bw
`!p snip.rv = guess_log_var()`.Warn().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msgf("$1", $2)
endsnippet

snippet lE "Log Error" bw
`!p snip.rv = guess_log_var()`.Error().
	Str("func", "`!p snip.rv = get_function_name()`").
	Err(err).
	Msg("$1")
endsnippet

snippet lEf "Log Error Format" bw
`!p snip.rv = guess_log_var()`.Error().
	Str("func", "`!p snip.rv = get_function_name()`").
	Err(err).
	Msgf("$1", $2)
endsnippet

snippet lf "Log Fatal" bw
`!p snip.rv = guess_log_var()`.Fatal().
	Str("func", "`!p snip.rv = get_function_name()`").
	Err(err).
	Msg("$1")
endsnippet

snippet lff "Log Fatal Format" bw
`!p snip.rv = guess_log_var()`.Fatal().
	Str("func", "`!p snip.rv = get_function_name()`").
	Err(err).
	Msgf("$1", $2)
endsnippet

snippet lp "Log Panic" "add_import('lp', snip, 'fmt')" bwe
`!p snip.rv = guess_log_var()`.Error().
	Str("func", "`!p snip.rv = get_function_name()`").
	Stack().
	Err(fmt.Errorf("%s", r)).
	Msg("A panic occurred$1")
endsnippet

snippet lpf "Log Panic Format" "add_import('lpf', snip, 'fmt')" bwe
`!p snip.rv = guess_log_var()`.Error().
	Str("func", "`!p snip.rv = get_function_name()`").
	Stack().
	Err(fmt.Errorf("%s", r)).
	Msgf("A panic occurred$1", $2)
endsnippet

snippet L "Lock" bw
`!p snip.rv = get_receiver_name()`.${1:lock}.Lock()
defer `!p snip.rv = get_receiver_name()`.$1.Unlock()
endsnippet

snippet Lr "Read Lock" bw
`!p snip.rv = get_receiver_name()`.${1:lock}.RLock()
defer `!p snip.rv = get_receiver_name()`.$1.RUnlock()
endsnippet

## M ##

snippet '^main ' "Main" brA
func main() {
	$0
}
endsnippet

snippet '^m([ *])' "Method" brA
// $1 TODO: Description.
func (`!p snip.rv = snip.c or ' '.join(find_method_type(match[1] == '*'))`) ${1: }($2)$3 {
	$0
}`!p t[1] = smart_capitalisation(t[1])`
endsnippet

snippet '^mr([ *])' "Method with self return" brA
// $1 TODO: Description.
func (`!p snip.rv = snip.c or ' '.join(find_method_type(match[1] == '*'))`) ${1: }($2) `!p snip.rv = snip.c or find_method_type(match[1] == '*')` {
	$0

	return `!p snip.rv = snip.c or find_method_type(match[1] == '*')[0]`
}`!p t[1] = smart_capitalisation(t[1])`
endsnippet

snippet mmj "Method - MarshalJSON" bw
func (`!p snip.rv = snip.c or ' '.join(find_method_type())`) MarshalJSON() ([]byte, error) {
	$0
}
endsnippet

snippet mmy "Method - MarshalYAML" bw
func (`!p snip.rv = snip.c or ' '.join(find_method_type())`) MarshalYAML() (interface{}, error) {
	$0
}
endsnippet

snippet muj "Method - UnmarshalJSON" bw
func (`!p snip.rv = snip.c or ' '.join(find_method_type(True))`) UnmarshalJSON(data []byte) error {
	$0
}
endsnippet

snippet muy "Method - UnmarshalYAML" "add_import('muy', snip, 'fmt')" bwe
func (`!p snip.rv = snip.c or ' '.join(find_method_type(True))`) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var ${1:val} ${2:interface{}}

	if err := unmarshal(&`!p snip.rv = snip.c or find_method_type()[0]`); err != nil {
		return fmt.Errorf("invalid YAML: %s", err)
	}

	$0
}
endsnippet

context "add_import('mo', snip, 'testing')"
snippet '^mo' "Interface Mock" brA
var mock $0
endsnippet

snippet 'var mock ([^\s]+) ' "Mock Generator" brA
type Mock`!p if not snip.c: snip.rv = get_interface_name(match[1])` struct {
	`!p if not snip.c: snip.rv = generate_mock(match[1])`
}
endsnippet

context "get_mock_signature(snip)"
snippet '([A-Za-z0-9_]+_Mock)(:)?' "Mock Test Method" re
`!p if not snip.c: snip.rv = match[1]``!p snip.rv = ':' if match[2] == ':' else ' ='` `!v b:__mock_type` {
	$0
}`!p snip.rv = ',' if match[2] == ':' else ''`
endsnippet

snippet ms "Method - String" "add_import('ms', snip, 'fmt')" bwe
func (`!p snip.rv = snip.c or ' '.join(find_method_type())`) String() string {
	return fmt.Sprintf("$1", $0)
}
endsnippet

snippet mE "Method - Error" bw
func (`!p snip.rv = snip.c or ' '.join(find_method_type())`) Error() string {
	return $0
}
endsnippet

snippet '^mv' "Method - Validation" "add_import('mv', snip, 'v github.com/go-ozzo/ozzo-validation')" breA
// Validate returns an error if any of the fields are invalid.
func (`!p snip.rv = snip.c or ' '.join(find_method_type(True))`) Validate() error {
	return v.ValidateStruct(`!p snip.rv = snip.c or find_method_type()[0]`,
		v.Field(&`!p snip.rv = snip.c or find_method_type()[0]`.$1),$0
	)
}
endsnippet

snippet Ms "Make slice"
make([]$1, 0$2)
endsnippet

snippet 'Ms(u?i[136]?|f[36]?|[sbBdr])' "Make slice of type" r
make([]`!p snip.rv = convert_type_map.get(match[1] or '', '')`, 0$1)
endsnippet

snippet MS "Make set"
make(map[${1:value}]struct{})
endsnippet

snippet Mm "Make map"
make(map[${1:key}]${2:value})
endsnippet

## O ##

context "add_import('oe ', snip, 'os')"
snippet 'oe ' "OS Exit" breA
os.Exit(${1:1})
endsnippet

## P ##

snippet P "panic" bw
panic($1)
endsnippet

snippet PE "panic - errer" bw
panic(err)
endsnippet

snippet Pni "panic - not implemented" bw
panic("Not implemented")
endsnippet

## R ##

snippet r "Return" bw
return ${0:${VISUAL}}
endsnippet

snippet 'r([ntf]) ' "Return Simple Value" brA
return `!p snip.rv = simple_value_map[match[1]]`
endsnippet

snippet '\br ' "Return (automatic)" brA
return $0
endsnippet

context "add_import('rE ', snip, 'errors')"
snippet '\brE ' "Return new error" brA
return $1errors.New("$0")
endsnippet

context "add_import('rEf ', snip, 'fmt')"
snippet '\brEf ' "Return new formatted error" brA
return $1fmt.Errorf("$2", ${3:err})
endsnippet

snippet rr "Receiver type with dot" wA
`!p snip.rv = get_receiver_name()`.
endsnippet

snippet RR "Receiver type" wA
`!p snip.rv = get_receiver_name()`
endsnippet

snippet R "Recover" bw
defer func() {
	if r := recover(); r != nil {
		$0
	}
}()
endsnippet

snippet Re "Recover Else" bw
defer func() {
	if r := recover(); r != nil {
		$0
	} else {
		``
	}
}()
endsnippet

## S ##

snippet 'spf' "Sprintf" "add_import('spf', snip, 'fmt')" re
fmt.Sprintf("$1", $0)
endsnippet

snippet ss "Sort Slice" "add_import('ss', snip, 'sort')" bwe
sort.Slice($1, func(i, j int) bool {
	return $1[i]$2 < $1[j]$2
})
endsnippet

snippet '^st' "Struct" brA
// $1 ${2:TODO: Description}.
type ${1: } struct {`!p t[1] = smart_capitalisation(t[1])`
	$0
}
endsnippet

snippet sw "Switch" b
switch $1 {
case $2:
	$0
}
endsnippet

snippet swt "Switch (Type)" b
switch $1 := $2.(type) {
case $3:
	$0
default:
	``
}
endsnippet

## T ##

snippet t "Test" bw
func Test`!p if not snip.c: snip.rv = guess_test_name()`$1(t *testing.T) {
	$0
}`!p t[1] = smart_capitalisation(t[1], non_alphanum_underscore)`
endsnippet

context "add_import('ta', snip, 'fmt', 'testing', 'github.com/stretchr/testify/assert')"
snippet ta "Test Array" bem
tests := []struct{
	$2
}{
	{
		$3
	},
}

for i, test := range tests {
	t.Run(fmt.Sprintf("Test %d of %d", i+1, len(tests)), func(s *testing.T) {
		assert := assert.New(s)

		$0
	})
}
endsnippet

snippet 'td ' "TODO Comment" brA
// `!p snip.rv = snip.c or start_dictation('TODO:')` $1
endsnippet

snippet tf "Test File" bw
import (
	"github.com/stretchr/testify/assert"
	"testing"
)

$0
endsnippet

snippet tt "Test with Template (Fail on Error)" bw
func Test`!p if not snip.c: snip.rv = guess_test_name()`$1(t *testing.T) {
	assert := assert.New(FailOnError(t))

	$0
}`!p t[1] = smart_capitalisation(t[1])`
endsnippet

snippet tb "Test Benchmark" bw
func Benchmark_$1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		$0
	}
}
endsnippet

snippet tbp "Test Benchmark - Parallel" bw
func Benchmark_$1(b *testing.B) {
	b.RunParallel(func (pb *testing.PB) {
		for pb.Next() {
			$0
		}
	})
}
endsnippet


snippet '^ty' "Type" brA
type ${1:Name} ${2:Type}
endsnippet

## V ##

snippet v "Validate" b
v.Field(&`!p snip.rv = get_receiver_type().split(' ')[0]`.$1),
endsnippet

snippet v.By "v.By rule" w
v.By(func(val interface{}) error {
	$0
})
endsnippet

## Symbols ##

snippet = "Assignment" bA
$1 := $0`!p t[1] = smart_capitalisation(t[1], cap_first=False)`
endsnippet

snippet e= "Error Assignment" bA
$1, err := $0`!p t[1] = smart_capitalisation(t[1], cap_first=False)`
endsnippet

snippet 2= "Assignment (2 arguments)" bA
$1, $2 := $0
endsnippet

snippet 3= "Assignment (3 arguments)" bA
$1, $2, $3 := $0
endsnippet

snippet 4= "Assignment (4 arguments)" bA
$1, $2, $3, $4 := $0
endsnippet
