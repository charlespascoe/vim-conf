# KEEP IN ALPHABETIC ORDER

global !p
struct_re = re.compile(r"^type (\w+) struct")
method_re = re.compile(r"^func \(([^)]+)\)\s+\w+\(")

def find_method_type():
	l = vim.current.window.cursor[0] - 1

	name = ''

	while l >= 0:
		line = vim.current.window.buffer[l]

		match = method_re.match(line)

		if match:
			return match[1]

		match = struct_re.match(line)

		if match:
			name = match[1]
			return (name[0] + re.sub('[a-z]', '', name[1:])).lower() + ' ' + name

		l -= 1

def find_type():
	l = vim.current.window.cursor[0] - 1

	name = ''

	while l >= 0:
		line = vim.current.window.buffer[l]

		match = struct_re.match(line)

		if match:
			return match[1]

		l -= 1

def get_receiver_type():
	l = vim.current.window.cursor[0] - 1

	name = ''

	no_leading_whitespace_re = re.compile('^[^\s]')

	while l >= 0:
		line = vim.current.window.buffer[l]

		match = no_leading_whitespace_re.match(line)

		if match:
			# Found the line before this line that doesn't have any leading whitespace,
			# possibly the method declaration
			match = method_re.match(line)

			if match:
				return match[1]
			else:
				# In this case, either we're in a regular function or not in any function at all
				return ''

		l -= 1

def guess_log_var():
	receiver_type = get_receiver_type()

	if receiver_type:
		return f"{receiver_type.split(' ')[0]}.log"

	return 'log'
endglobal

## A ##

snippet ap "Append to slice"
$1 = append($1, $0)
endsnippet

## C ##

snippet c "Channel" bw
$1 := make(chan $2)
endsnippet

snippet cd "Channel with deferred close" bw
$1 := make(chan $2)
defer close($1)
endsnippet

## F ##

snippet f "Function" bw
func $1() {
	$0
}
endsnippet

snippet fc "Function - Constructor" bw
func New$1($2) *$1 {
	return &${1:`!p snip.rv = find_type() or 'Type'`} {
		$0
	}
}
endsnippet

snippet fcl "Function - Constructor with Log" bw
func New$1($2) *$1 {
	return &${1:`!p snip.rv = find_type() or 'Type'`} {
		log: log.With().
			Str("cls", "$1").
			Logger(),
		$0
	}
}
endsnippet

snippet for "For" bw
for $1{
	$0
}
endsnippet

snippet forc "For channel" bw
for $1 := range $2 {
	$0
}
endsnippet

snippet fore "For each" bw
for ${1:_}, $2 := range $3 {
	$0
}
endsnippet

snippet fori "For counter (i)" bw
for i := ${1:0}; i < $2; i++ {
	$0
}
endsnippet

snippet fr "Function with Return" bw
func $1() $2 {
	return $0
}
endsnippet

## G ##

snippet go "Goroutine of an anonymous function"
go func() {
	$0
}()
endsnippet

## I ##

snippet i "If" bw
if $1 {
	$0
}
endsnippet

snippet ie "If-else" bw
if $1 {
	$0
} else {
	
}
endsnippet

snippet ier "If error" bw
if err != nil {
	$0
}
endsnippet

snippet ierr "If error, return" bw
if err != nil {
	return $1fmt.Errorf("$2: %s$3", err$4)
}
endsnippet

snippet im "import" bw
import (
	$0
)
endsnippet

snippet in "Interface" bw
type $1 interface {
	$0
}
endsnippet

## L ##

snippet ld "Log Debug" bw
${1:`!p snip.rv = guess_log_var()`}.Debug().
	Msg("$3")
endsnippet

snippet ldf "Log Debug Format" bw
${1:`!p snip.rv = guess_log_var()`}.Debug().
	Msgf("$2", $3)
endsnippet

snippet li "Log Info" bw
${1:`!p snip.rv = guess_log_var()`}.Info().
	Msg("$3")
endsnippet

snippet lif "Log Info Format" bw
${1:`!p snip.rv = guess_log_var()`}.Info().
	Msgf("$2", $3)
endsnippet

snippet lw "Log Warn" bw
${1:`!p snip.rv = guess_log_var()`}.Warn().
	Msg("$3")
endsnippet

snippet lwf "Log Warn Format" bw
${1:`!p snip.rv = guess_log_var()`}.Warn().
	Msgf("$2", $3)
endsnippet

snippet le "Log Error" bw
${1:`!p snip.rv = guess_log_var()`}.Error().
	Err(${2:err}).
	Msg("$3")
endsnippet

snippet lef "Log Error Format" bw
${1:`!p snip.rv = guess_log_var()`}.Error().
	Err(${2:err}).
	Msgf("$3", $4)
endsnippet

snippet lf "Log Fatal" bw
${1:`!p snip.rv = guess_log_var()`}.Fatal().
	Err(${2:err}).
	Msg("$3")
endsnippet

snippet lff "Log Fatal Format" bw
${1:`!p snip.rv = guess_log_var()`}.Fatal().
	Err(${2:err}).
	Msgf("$3", $4)
endsnippet

snippet L "Lock" bw
$1.Lock()
defer $1.Unlock()
endsnippet

## M ##

snippet m "Method" bw
func (${1:`!p snip.rv = find_method_type()`}) $2($3) {
	$0
}
endsnippet

snippet mr "Method with return" bw
func (${1:`!p snip.rv = find_method_type()`}) $2($3) $4 {
	return $0
}
endsnippet

snippet ms "Method - String" bw
func (${1:`!p snip.rv = find_method_type()`}) String() string {
	return $0
}
endsnippet

snippet mv "Method - Validation" bw
func (${1:`!p snip.rv = find_method_type()`}) Validate() error {
	return v.Validate(`!p snip.rv = t[1].split(' ')[0]`,
		v.Field(&`!p snip.rv = t[1].split(' ')[0]`.$3),
	)
}
endsnippet

## R ##

snippet r "Return" bw
return $0
endsnippet

## S ##

snippet st "Struct" bw
type $1 struct {
	$0
}
endsnippet

## T ##

snippet t "Test" bw
func Test$1(t *testing.T) {
	$0
}
endsnippet

snippet ta "Test Array" bw
func Test$1(t *testing.T) {
	assert := assert.New(t)

	tests := []struct{
		$1
	}{
		{
			$2
		},
	}

	for _, test := range tests {
		$0
	}
}
endsnippet

snippet tf "Test File" bw
import (
	"github.com/stretchr/testify/assert"
	"testing"
)

$0
endsnippet

snippet tt "Test with Template" bw
func Test$1(t *testing.T) {
	assert := assert.New(t)

	$0
}
endsnippet

snippet tb "Test Benchmarck" bw
func Benchmark$1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		$0
	}
}
endsnippet
