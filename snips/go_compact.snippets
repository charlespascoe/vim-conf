# KEEP IN ALPHABETIC ORDER

## A ##

snippet ap "Append to slice"
$1 = append($1, $0)
endsnippet

## C ##

snippet c "Channel" bw
$1 := make(chan $2)
endsnippet

snippet cd "Channel with deferred close" bw
$1 := make(chan $2)
defer close($1)
endsnippet

## F ##

snippet f "Function" bw
func $1() {
	$0
}
endsnippet

snippet fc "Function - Constructor" bw
func New$1($2) *$1 {
	return &${1:Type} {
		$0
	}
}
endsnippet

snippet fcl "Function - Constructor with Log" bw
func New$1($2) *$1 {
	return &${1:Type} {
		log: log.With().
			Str("cls", "$1").
			Logger(),
		$0
	}
}
endsnippet

snippet for
for $1{
	$0
}
endsnippet

snippet forc
for $1 := range $2 {
	$0
}
endsnippet

snippet fore
for ${1:_}, $2 := range $3 {
	$0
}
endsnippet

snippet fori
for i := ${1:0}; i < $2; i++ {
	$0
}
endsnippet

snippet fr "Function with Return" bw
func $1() $2 {
	return $0
}
endsnippet

## G ##

snippet go "Goroutine of an anonymous function"
go func() {
	$0
}()
endsnippet

## I ##

snippet i "If" bw
if $1 {
	$0
}
endsnippet

snippet ie "If-else" bw
if $1 {
	$0
} else {
	
}
endsnippet

snippet ier "If error" bw
if err != nil {
	$0
}
endsnippet

snippet ierr "If error, return" bw
if err != nil {
	return $1fmt.Errorf("$2: %s$3", err$4)
}
endsnippet

snippet im "import" bw
import (
	$0
)
endsnippet

snippet in "Interface" bw
type $1 interface {
	$0
}
endsnippet

## L ##

snippet ld "Log Debug" bw
${1:log}.Debug().
	Msg("$3")
endsnippet

snippet ldf "Log Debug Format" bw
${1:log}.Debug().
	Msgf("$2", $3)
endsnippet

snippet li "Log Info" bw
${1:log}.Info().
	Msg("$3")
endsnippet

snippet lif "Log Info Format" bw
${1:log}.Info().
	Msgf("$2", $3)
endsnippet

snippet lw "Log Warn" bw
${1:log}.Warn().
	Msg("$3")
endsnippet

snippet lwf "Log Warn Format" bw
${1:log}.Warn().
	Msgf("$2", $3)
endsnippet

snippet le "Log Error" bw
${1:log}.Error().
	Err(${2:err}).
	Msg("$3")
endsnippet

snippet lef "Log Error Format" bw
${1:log}.Error().
	Err(${2:err}).
	Msgf("$3", $4)
endsnippet

snippet lf "Log Fatal" bw
${1:log}.Fatal().
	Err(${2:err}).
	Msg("$3")
endsnippet

snippet lff "Log Fatal Format" bw
${1:log}.Fatal().
	Err(${2:err}).
	Msgf("$3", $4)
endsnippet

snippet L "Lock" bw
$1.Lock()
defer $1.Unlock()
endsnippet

## M ##

global !p
def get_last_method_type():
	vim.command("let b:go_last_method_type = exists(b:go_last_method_type) ? b:go_last_method_type :  ")
	return vim.eval("b:go_last_method_type")

def set_last_method_type(name):
	vim.command("let b:go_last_method_type = %s"% name)
	return name
endglobal

snippet m "Method" bw
func (${1:`!p snip.rv = get_last_method_type()`}) $2($3) $4 {
	$0
}`!p set_last_method_type(t[1])`
endsnippet

snippet ms "Method - String" bw
func (${1:`!p snip.rv = get_last_method_type()`}) String() string {
	return $0
}`!p set_last_method_type(t[1])`
endsnippet

snippet mv "Method - Validation" bw
func (${1:name} ${2:Type}) Validate() error {
	return v.Validate($1,
		v.Field(&$1.$3),
	)
}`!p set_last_method_type(t[1])`
endsnippet

## S ##

snippet st "Struct" bw
type $1 struct {
	$0
}
endsnippet

## T ##

snippet t "Test" bw
func Test$1(t *testing.T) {
	$0
}
endsnippet

snippet ta "Test Array" bw
func Test$1(t *testing.T) {
	assert := assert.New(t)

	tests := []struct{
		$1
	}{
		{
			$2
		},
	}

	for _, test := range tests {
		$0
	}
}
endsnippet

snippet tf "Test File" bw
import (
	"github.com/stretchr/testify/assert"
	"testing"
)

$0
endsnippet

snippet tt "Test with Template" bw
func Test$1(t *testing.T) {
	assert := assert.New(t)

	$0
}
endsnippet

snippet tb "Test Benchmarck" bw
func Benchmark$1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		$0
	}
}
endsnippet
