# KEEP IN ALPHABETIC ORDER

global !p
type_re = re.compile(r"^type (\w+)")
struct_re = re.compile(r"^type (\w+) struct")
method_re = re.compile(r"^func \(([^)]+)\)\s+(\w+)\(")
func_re = re.compile(r"^func (\w+)\(")
test_re = re.compile(r"^func Test([^)]*)\(")
import_re = re.compile(r'^import \($')

convert_type_map = {
	'i':   'int',
	'i1':  'int16',
	'i3':  'int32',
	'i6':  'int64',
	'ui1': 'uint16',
	'ui3': 'uint32',
	'ui6': 'uint64',

	's': 'string',

	'f': 'float',
	'f3': 'float32',
	'f6': 'float64',

	'b': 'byte',
}


def preceeding_lines():
	l = vim.current.window.cursor[0] - 2

	while l > 0:
		yield vim.current.window.buffer[l]
		l -= 1


def find_method_type(pointer=False):
	for line in preceeding_lines():
		match = method_re.match(line)

		if match:
			rec_name, _, rec_type = match[1].partition(' ')

			if pointer and '*' not in rec_type:
				rec_type = '*' + rec_type

			return (rec_name, rec_type)

		match = type_re.match(line)

		if match:
			name = match[1]
			rec_type = name

			if pointer:
				rec_type = '*' + rec_type

			rec_name = (name[0] + re.sub('[a-z]', '', name[1:])).lower()

			return (rec_name, rec_type)

	return ('', 'nil')


def find_type():
	for line in preceeding_lines():
		match = type_re.match(line)

		if match:
			return match[1]

	return ''


def get_receiver_type():
	no_leading_whitespace_re = re.compile('^[^\s]')

	for line in preceeding_lines():
		match = no_leading_whitespace_re.match(line)

		if match:
			# Found the line before this line that doesn't have any leading whitespace,
			# possibly the method declaration
			match = method_re.match(line)

			if match:
				return match[1]
			else:
				# In this case, either we're in a regular function or not in any function at all
				return ''


def guess_log_var():
	receiver_type = get_receiver_type()

	if receiver_type:
		return f"{receiver_type.split(' ')[0]}.log"

	return 'log'


def guess_test_name():
	# NOTE: It is VERY important that this function ALWAYS returns a non-empty
	# string, so that the snippet pluging doesn't run this function more than
	# once per template

	for line in preceeding_lines():
		match = test_re.match(line)

		if match:
			parts = [part for part in match[1].split('_') if len(part) > 0]

			if len(parts) > 1:
				# All but the last item
				return '_' + '_'.join(parts[:-1]) + '_'
			else:
				break

	return '_'


def get_function_name():
	for line in preceeding_lines():
		match = func_re.match(line)

		if match:
			return match[1]

		match = method_re.match(line)

		if match:
			return match[2]

	return ''


def previous_test_name():
	for line in preceeding_lines():
		match = test_re.match(line)

		if match:
			return match[1]

	return ''

# Returns the zero-based index of the first line that matches the regexp
def find_line(regexp):
	for i in range(len(vim.current.window.buffer)):
		if regexp.match(vim.current.window.buffer[i]):
			return i

	return None

def add_import(prefix, snip, *imports):
	if not snip.buffer[snip.line][:snip.column+1].endswith(prefix):
		return False

	# imports = [(f'"{pkg}"' if '"' not in pkg else pkg) for pkg in imports ]
	imports = list(imports)

	index = find_line(import_re)

	if index is None:
		return True

	for i in range(index + 1, len(vim.current.window.buffer)):
		line = vim.current.window.buffer[i].strip()

		for imp_idx in range(len(imports)):
			if line == imports[imp_idx]:
				imports.pop(imp_idx)

		if line == ')':
			if len(imports) > 0:
				for imp in imports:
					# End of imports - not found, so just add it
					parts = imp.split(' ')

					if len(parts) > 1:
						alias, path = parts[0], parts[1]
						vim.command(f'GoImportAs {alias} {path}')
					else:
						vim.command(f'GoImport {imp}')

			return True

# ends_with_non_letter = re.compile(r'[^a-zA-Z]$')
non_alphanum_underscore = re.compile(r'[^a-zA-Z0-9_]')

def capitalise(s, remove=None):
	cap = True

	for i in range(len(s)):
		if s[i].isalpha():
			if cap:
				s = s[:i] + s[i].upper() + s[i+1:]
			cap = False
		else:
			cap = True

	if remove is not None:
		s = remove.sub('', s)

	return s

endglobal

## A ##

snippet ap "Append to slice"
$1 = append($1, $0)
endsnippet

snippet Ae "Assert Equal" bw
assert.Equal(${1:expected}, ${2:actual})
endsnippet

snippet Af "Assert False" bw
assert.False(${1:actual})
endsnippet

snippet Aem "Assert Equal with Message" bw
assert.Equal(${1:expected}, ${2:actual}, "${3:message}")
endsnippet

snippet Al "Assert Length" bw
assert.Len(${1:result}, ${2:length})
endsnippet

snippet Ane "Assert Not Equal" bw
assert.NotEqual(${1:expected}, ${2:actual})
endsnippet

snippet Anem "Assert Not Equal with Message" bw
assert.NotEqual(${1:expected}, ${2:actual}, "${3:message}")
endsnippet

snippet Aner "Assert No Error" bw
assert.NoError(${1:err})
endsnippet

snippet Anerm "Assert No Error with Message" bw
assert.NoError(${1:err}, "${2:message}")
endsnippet

snippet An "Assert Nil" bw
assert.Nil(${1:value})
endsnippet

snippet Anm "Assert Nil with Message" bw
assert.Nil(${1:value}, "${2:message}")
endsnippet

snippet Ann "Assert Not Nil" bw
assert.NotNil(${1:value})
endsnippet

snippet Annm "Assert Not Nil with Message" bw
assert.NotNil(${1:value}, "${2:message}")
endsnippet

snippet At "Assert True" bw
assert.True(${1:actual})
endsnippet

## C ##

snippet c "Channel" bw
$1 := make(chan $2)
endsnippet

snippet cd "Channel with deferred close" bw
$1 := make(chan $2)
defer close($1)
endsnippet

snippet '\bc(\[\])?(u?i[136]?|f[36]?|s|b)\b' "Convert to Type" r
`!p snip.rv = match.group(1) or ''``!p snip.rv = convert_type_map[match.group(2)]`(${VISUAL}$1)
endsnippet

snippet '\bc\?\b' "Convert to Arbitrary Type" r
$1(${VISUAL}$2)
endsnippet

## D ##

snippet dc "Done Channel" bw
done := make(chan struct{})
defer close(done)
endsnippet

## E ##

snippet 'Ef' "Errorf" "add_import('Ef', snip, 'fmt')" re
fmt.Errorf("$1", $2)
endsnippet

snippet 'Eft' "Errorf with error template" "add_import('Eft', snip, 'fmt')" re
fmt.Errorf("$1: %s",$2 err)
endsnippet

## F ##

snippet f "Function" bw
// $1 ${4:TODO: Description}.
func ${1: }($2)$3 {
	$0
}
endsnippet

snippet fr "Function with Return" bw
// $1 ${4:TODO: Description}.
func ${1: }($2) $3 {
	return $0
}
endsnippet

snippet '(?<=.)\bf' "Anonymous Function" r
func($1)$2 {
	$0
}
endsnippet

snippet '(?<=.)\bfr' "Anonymous Function with Return" r
func($1) $2 {
	return $0
}
endsnippet

snippet fc "Function - Constructor" bw
func New$1($2) *$1 {
	return &${1:`!p snip.rv = find_type() or 'Type'`}{
		$0
	}
}
endsnippet

snippet fcl "Function - Constructor with Log" "add_import('fcl', snip, 'github.com/rs/zerolog/log')" bwe
func New$1($2) *$1 {
	return &${1:`!p snip.rv = find_type() or 'Type'`}{
		$0
		log: log.With().
			Str("cls", "$1").
			Logger(),
	}
}
endsnippet

snippet for "For" bw
for $1{
	$0
}
endsnippet

snippet forc "For channel" bw
for $1 := range $2 {
	$0
}
endsnippet

snippet fore "For each" bw
for ${1:_}, $2 := range $3 {
	$0
}
endsnippet

snippet fori "For counter (i)" bw
for i := ${1:0}; i < $2; i++ {
	$0
}
endsnippet

## G ##

snippet go "Goroutine of an anonymous function"
go func() {
	$0
}()
endsnippet

## I ##

# TODO: Consider unifying the "If" snippets

snippet i "If" bw
if $1 {
	$0
}
endsnippet

snippet ie "If-else" bw
if $1 {
	$0
} else {
	``
}
endsnippet

snippet in "If nil" bw
if $1 == nil {
	$0
}
endsnippet

snippet inn "If not nil" bw
if $1 != nil {
	$0
}
endsnippet

snippet is "If short" bw
if $1 := $2; $3 {
	$0
}
endsnippet

snippet ise "If short, else" bw
if $1 := $2; $3 {
	$0
} else {
	``
}
endsnippet

snippet iE "If error" bw
if err != nil {
	$0
}
endsnippet

snippet iEr "If error, return" "add_import('iEr', snip, 'fmt')" bwe
if err != nil {
	return $1fmt.Errorf("$2: %s",$3 err)
}
endsnippet

snippet isE "If short error" bw
if $1err := ${VISUAL:/^.*err :?= //}$2; err != nil {
	$0
}
endsnippet

snippet isEr "If short error, return" "add_import('isEr', snip, 'fmt')" bwe
if $1err := ${VISUAL:/^.*err :?= //}$2; err != nil {
	return $3fmt.Errorf("$4: %s",$5 err)
}
endsnippet

snippet isju "If Short JSON Unmarshal" "add_import('isju', snip, 'encoding/json')" bwe
if err := json.Unmarshal(${1:data}, $2); err != nil {
	$0
}
endsnippet

snippet isjur "If Short JSON Unmarshal, return" "add_import('isjur', snip, 'encoding/json', 'fmt')" bwe
if err := json.Unmarshal(${1:data}, $2); err != nil {
	return $3fmt.Errorf("$4: %s",$5 err)
}
endsnippet

snippet isv "If Short Validate" bw
if err := $1.Validate(); err != nil {
	$0
}
endsnippet

snippet isvr "If Short Validate, return" bw
if err := $1.Validate(); err != nil {
	return $3fmt.Errorf("$4: %s",$5 err)
}
endsnippet

snippet ilz "If Length Zero" bw
if len(${1: }) == 0 {
	$0
}
endsnippet

snippet ilze "If Length Zero Else" bw
if len(${1: }) == 0 {
	$0
} else {
	``
}
endsnippet

snippet ilnz "If Length Not Zero" bw
if len(${1: }) > 0 {
	$0
}
endsnippet

snippet im "import" bw
import (
	$0
)
endsnippet

snippet int "Interface" bw
// $1 ${2:TODO: Description}.
type ${1: } interface {
	$0
}
endsnippet

## J ##

snippet jm "JSON Marshal" "add_import('jm', snip, 'encoding/json')" bwe
${1:data}, err := json.Marshal(${2:${VISUAL}})
endsnippet

snippet ju "JSON Unmarshal" "add_import('ju', snip, 'encoding/json')" bwe
err := json.Unmarshal(${1:data}, $2)
endsnippet

## L ##

snippet ld "Log Debug" bw
`!p snip.rv = guess_log_var()`.Debug().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msg("$1")
endsnippet

snippet ldf "Log Debug Format" bw
`!p snip.rv = guess_log_var()`.Debug().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msgf("$1", $2)
endsnippet

snippet li "Log Info" bw
`!p snip.rv = guess_log_var()`.Info().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msg("$1")
endsnippet

snippet lif "Log Info Format" bw
`!p snip.rv = guess_log_var()`.Info().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msgf("$1", $2)
endsnippet

snippet lw "Log Warn" bw
`!p snip.rv = guess_log_var()`.Warn().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msg("$1")
endsnippet

snippet lwf "Log Warn Format" bw
`!p snip.rv = guess_log_var()`.Warn().
	Str("func", "`!p snip.rv = get_function_name()`").
	Msgf("$1", $2)
endsnippet

snippet le "Log Error" bw
`!p snip.rv = guess_log_var()`.Error().
	Str("func", "`!p snip.rv = get_function_name()`").
	Err(err).
	Msg("$1")
endsnippet

snippet lef "Log Error Format" bw
`!p snip.rv = guess_log_var()`.Error().
	Str("func", "`!p snip.rv = get_function_name()`").
	Err(err).
	Msgf("$1", $2)
endsnippet

snippet lf "Log Fatal" bw
`!p snip.rv = guess_log_var()`.Fatal().
	Str("func", "`!p snip.rv = get_function_name()`").
	Err(err).
	Msg("$1")
endsnippet

snippet lff "Log Fatal Format" bw
`!p snip.rv = guess_log_var()`.Fatal().
	Str("func", "`!p snip.rv = get_function_name()`").
	Err(err).
	Msgf("$1", $2)
endsnippet

snippet lp "Log Panic" "add_import('lp', snip, 'fmt')" bwe
`!p snip.rv = guess_log_var()`.Error().
	Str("func", "`!p snip.rv = get_function_name()`").
	Stack().
	Err(fmt.Errorf("%s", r)).
	Msg("A panic occurred$1")
endsnippet

snippet lpf "Log Panic Format" "add_import('lpf', snip, 'fmt')" bwe
`!p snip.rv = guess_log_var()`.Error().
	Str("func", "`!p snip.rv = get_function_name()`").
	Stack().
	Err(fmt.Errorf("%s", r)).
	Msgf("A panic occurred$1", $2)
endsnippet


snippet L "Lock" bw
$1.Lock()
defer $1.Unlock()
endsnippet

snippet Lr "Read Lock" bw
$1.RLock()
defer $1.RUnlock()
endsnippet

## M ##

snippet m "Method" bw
// $2 ${5:TODO: Description}.
func (${1:`!p snip.rv = snip.c or find_method_type()[0]`} `!p snip.rv = snip.c or find_method_type()[1]`) ${2: }($3)$4 {
	$0
}
endsnippet

# TODO: Improve forced pointer handling
snippet m* "Method" bw
// $2 ${5:TODO: Description}.
func (${1:`!p snip.rv = snip.c or find_method_type(True)[0]`} `!p snip.rv = snip.c or find_method_type(True)[1]`) ${2: }($3)$4 {
	$0
}
endsnippet

snippet mmj "Method - MarshalJSON" bw
func (${1:`!p snip.rv = snip.c or find_method_type()[0]`} `!p snip.rv = snip.c or find_method_type()[1]`) MarshalJSON() ([]byte, error) {
	$0
}
endsnippet

snippet mmy "Method - MarshalJSON" bw
func (${1:`!p snip.rv = snip.c or find_method_type()[0]`} `!p snip.rv = snip.c or find_method_type()[1]`) MarshalYAML() (interface{}, error) {
	$0
}
endsnippet

snippet muj "Method - UnmarshalJSON" bw
func (${1:`!p snip.rv = snip.c or find_method_type(True)[0]`} `!p snip.rv = snip.c or find_method_type(True)[1]`) UnmarshalJSON(data []byte) error {
	$0
}
endsnippet

snippet muy "Method - UnmarshalYAML" "add_import('muy', snip, 'fmt')" bwe
func (${1:`!p snip.rv = snip.c or find_method_type(True)[0]`} `!p snip.rv = snip.c or find_method_type(True)[1]`) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var ${2:val} ${3:interface{}}

	if err := unmarshal(&$2); err != nil {
		return fmt.Errorf("invalid YAML: %s", err)
	}

	$0
}
endsnippet

snippet ms "Method - String" "add_import('ms', snip, 'fmt')" bwe
func (${1:`!p snip.rv = snip.c or find_method_type()[0]`} `!p snip.rv = snip.c or find_method_type()[1]`) String() string {
	return fmt.Sprintf("$2", $0)
}
endsnippet

snippet mE "Method - Error" bw
func (${1:`!p snip.rv = snip.c or find_method_type()[0]`} `!p snip.rv = snip.c or find_method_type()[1]`) Error() string {
	return $0
}
endsnippet

snippet mv "Method - Validation" "add_import('mv', snip, 'v github.com/go-ozzo/ozzo-validation')" bwe
// Validate returns an error if any of the fields are invalid.
func (${1:`!p snip.rv = snip.c or find_method_type(True)[0]`} `!p snip.rv = snip.c or find_method_type(True)[1]`) Validate() error {
	return v.ValidateStruct(`!p snip.rv = t[1].split(' ')[0]`,
		v.Field(&`!p snip.rv = t[1].split(' ')[0]`.$2),$0
	)
}
endsnippet

## R ##

snippet r "Return" bw
return ${0:${VISUAL}}
endsnippet

snippet R "Recover" bw
defer func() {
	if r := recover(); r != nil {
		$0
	}
}()
endsnippet

snippet Re "Recover Else" bw
defer func() {
	if r := recover(); r != nil {
		$0
	} else {
		``
	}
}()
endsnippet

## S ##

snippet 'spf' "Sprintf" "add_import('spf', snip, 'fmt')" re
fmt.Sprintf("$1", $0)
endsnippet

snippet ss "Sort Slice" "add_import('ss', snip, 'sort')" bwe
sort.Slice($1, func(i, j int) bool {
	return $1[i]$2 < $1[j]$2
})
endsnippet

snippet st "Struct" bw
// $1 ${2:TODO: Description}.
type ${1: } struct {
	$0
}
endsnippet

snippet stl "Struct with Log" "add_import('stl', snip, 'github.com/rs/zerolog')" bwe
// $1 ${2:TODO: Description}.
type ${1: } struct {
	$0
	log zerolog.Logger
}
endsnippet

## T ##

#// ${2:Test Description}.
snippet t "Test" bw
func Test`!p if not snip.c: snip.rv = guess_test_name()`$1(t *testing.T) {
	$0
}
endsnippet

#// ${2:Test Description}.
snippet ta "Test Array" "add_import('ta', snip, 'fmt', 'testing', 'github.com/stretchr/testify/assert')" bwe
func Test`!p if not snip.c: snip.rv = guess_test_name()`$1(t *testing.T) {
	tests := []struct{
		Description string
		$3
	}{
		{
			Description: "$4"
			$5
		},
	}

	for i, test := range tests {
		t.Run(fmt.Sprintf("Test %d of %d", i+1, len(tests)), func(s *testing.T) {
			assert := assert.New(s)

			assert.Equal(test.Result, $0, test.Description)
		})
	}
}
endsnippet

snippet tf "Test File" bw
import (
	"github.com/stretchr/testify/assert"
	"testing"
)

$0
endsnippet

snippet tFoE "Fail on Error" "add_import('tFoE', snip, 'testing')" bwe
func FailOnError(t *testing.T) FailOnErrorT {
	return FailOnErrorT{T: t}
}

// A wrapper for *testing.T to stop the test on the first error
type FailOnErrorT struct {
	*testing.T
}

func (t FailOnErrorT) Errorf(format string, args ...interface{}) {
	t.T.Helper()
	t.T.Fatalf(format, args...)
}
endsnippet

snippet tt "Test with Template" bw
// ${2:Test Description}.`!p t[1] = capitalise(t[1], non_alphanum_underscore)`
func Test`!p if not snip.c: snip.rv = guess_test_name()`$1(t *testing.T) {
	assert := assert.New(t)

	$0
}
endsnippet

snippet ttf "Test with Template (Fail on Error)" bw
// ${2:Test Description}.`!p t[1] = capitalise(t[1], non_alphanum_underscore)`
func Test`!p if not snip.c: snip.rv = guess_test_name()`$1(t *testing.T) {
	assert := assert.New(FailOnError(t))

	$0
}
endsnippet

snippet tb "Test Benchmark" bw
func Benchmark$1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		$0
	}
}
endsnippet

snippet tbp "Test Benchmark - Parallel" bw
func Benchmark$1(b *testing.B) {
	b.RunParallel(func (pb *testing.PB) {
		for pb.Next() {
			$0
		}
	})
}
endsnippet

snippet tm "Test Main" bw
import (
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"os"
	"testing"
)

func TestMain(m *testing.M) {
	log.Logger = log.Output(zerolog.ConsoleWriter{
		Out:        os.Stderr,
		TimeFormat: "15:04:05",
	})
	zerolog.SetGlobalLevel(zerolog.TraceLevel)

	code := m.Run()

	os.Exit(code)
}
endsnippet

## V ##

snippet v "Validate" b
v.Field(&`!p snip.rv = get_receiver_type().split(' ')[0]`.$1),
endsnippet

snippet v.By "v.By rule" w
v.By(func(val interface{}) error {
	$0
})
endsnippet

## Symbols ##

snippet = "Assignment" b
$1 := $0
endsnippet

snippet =2 "Assignment (2 arguments)" b
$1, $2 := $0
endsnippet

snippet =3 "Assignment (3 arguments)" b
$1, $2, $3 := $0
endsnippet

snippet =4 "Assignment (4 arguments)" b
$1, $2, $3, $4 := $0
endsnippet
