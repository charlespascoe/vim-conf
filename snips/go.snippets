snippet 'impo?r?t?' "Import" r
import (
	"$0"
)
endsnippet

snippet 'fun' "Function" r
func $1($2) $3 {
	$0
}
endsnippet

snippet defer
defer func() {
	$0
}()
endsnippet

global !p
def get_last_method_type():
	vim.command("let b:go_last_method_type = exists('b:go_last_method_type') ? b:go_last_method_type : ' '")
	return vim.eval("b:go_last_method_type")

def set_last_method_type(name):
	vim.command("let b:go_last_method_type = '%s'"% name)
	return name
endglobal

snippet 'meth?o?d?' "Method" r
func (${1:`!p snip.rv = get_last_method_type()`}) $2($3) $4 {
	$0
}`!p set_last_method_type(t[1])`
endsnippet

snippet han
func(res http.ResponseWriter, req *http.Request) {
	$0
}
endsnippet

snippet ehan
func(res http.ResponseWriter, req *http.Request) error {
	$0

	return nil
}
endsnippet

snippet for
for $1{
	$0
}
endsnippet

snippet fori
for i := ${1:0}; i < $2; i++ {
	$0
}
endsnippet

snippet fore
for ${1:_}, $2 := range $3 {
	$0
}
endsnippet

snippet drain
for _ = range $0 { }
endsnippet

snippet err
if err != nil {
	return$1 fmt.Errorf("$2: %s",$3 err)
}
endsnippet

snippet ierr
if err := $1; err != nil {
	return$2 fmt.Errorf("$3: %s", err)
}
endsnippet

snippet herr "Error with HTTP response"
if err != nil {
	log.Error().
		Err(err).
		Msg("$1")

	c.JSON(http.Status${2:InternalServerError}, gin.H{
		"error": "$1",
	})

	return
}
endsnippet

snippet c.JSON
c.JSON(http.Status${1:OK}, $2)
endsnippet

snippet 'http\.' "HTTP Status Autofil" r
http.Status${1:OK}
endsnippet

snippet respErr
if respErr := checkResponse("$1", resp, err); respErr != nil {
	return$2 respErr
}
endsnippet

snippet s "Struct"
type $1 struct {
	$0
}
endsnippet

snippet i "Interface"
type $1 interface {
	$0
}
endsnippet

snippet sel "Select"
select {
case $1:
	$0
}
endsnippet

snippet recover "Recover"
defer func() {
	if r := recover(); r != nil {
		$0
	}
}()
endsnippet

snippet j "JSON field"
$1 ${2:T} \`json:"${3:`!p snip.rv = "" if len(t[1]) == 0 else t[1][0].lower() + t[1][1:]`}"\`
endsnippet

snippet y "YAML field"
$1 ${2:T} \`yaml:"${3:`!p snip.rv = "" if len(t[1]) == 0 else t[1][0].lower() + t[1][1:]`}"\`
endsnippet

snippet chan "Channel with deferred close"
$1 := make(chan $0)
defer close($1)
endsnippet

snippet lock "Lock"
$1.Lock()
defer $1.Unlock()$0
endsnippet

snippet go "Goroutine of an anonymous function"
go func() {
	$0
}()
endsnippet

snippet if
if $1 {
	$0
}
endsnippet

snippet ife
if $1 {
	$0
} else {
	
}
endsnippet

snippet ap "Append to slice"
$1 = append($1, $0)
endsnippet

snippet 'spf' "Sprintf" r
fmt.Sprintf("$1", $0)
endsnippet

## GIN ROUTES ##
snippet '\.(GET|POST|PUT|DELETE)' "Gin Route" r
.`!p snip.rv = match.group(1)`("$1", func(c *gin.Context) {
	$0
})
endsnippet

### TESTING ###

snippet testfile
import (
	"github.com/stretchr/testify/assert"
	"testing"
)

$0
endsnippet

snippet apitestutils
import (
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
)

func executeRequest(t *testing.T, server *gin.Engine, req *http.Request) *httptest.ResponseRecorder {
	if req == nil {
		t.Fatal("executeRequest: req shoud not be nil")
	}

	if server == nil {
		t.Fatal("executeRequest: server shoud not be nil")
	}

	rr := httptest.NewRecorder()

	server.ServeHTTP(rr, req)

	return rr
}

func newRequest(t *testing.T, method, url string, body io.Reader) *http.Request {
	req, err := http.NewRequest(method, url, body)

	if err != nil {
		t.Fatalf("Error occurred when attempting to create a request: %s", err)
	}

	return req
}
endsnippet

snippet '^test' "Test Function" r
func Test$1(t *testing.T) {
	$0
}
endsnippet

snippet '^Test' "Test Function with Template" r
func Test$1(t *testing.T) {
	assert := assert.New(t)

	result := $0
}
endsnippet

snippet '^benc?h?' "Benchmark Function" r
func Benchmark$1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		$0
	}
}
endsnippet
