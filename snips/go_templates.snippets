global !p
from go_snippet_utils import add_import
endglobal

snippet argutils "Argument Parsing Utilities" b
import (
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"
)

var output = os.Stderr

type Subcommand struct {
	Name string
	Help string
	Exec func(args []string)
}

type PosArg struct {
	Name string
	Help string
	Meta string
}

func (posArg PosArg) GetMetaVar() string {
	if posArg.Meta != "" {
		return posArg.Meta
	}

	return posArg.Name
}

type HelpFormatter struct {
	Description    string
	Flags          *flag.FlagSet
	PositionalArgs []PosArg
	Subcommands    []Subcommand
}

func (helpFmt HelpFormatter) PrintUsage() {
	Logf("Usage: %s", helpFmt.Flags.Name())

	hasOptions := helpFmt.HasAnyOptions()

	if hasOptions {
		Logf(" <options>")
	}

	maxLen := 0

	if len(helpFmt.PositionalArgs) > 0 {
		for _, posArg := range helpFmt.PositionalArgs {
			if len(posArg.Name) > maxLen {
				maxLen = len(posArg.Name)
			}

			Logf(" %s", posArg.GetMetaVar())
		}
	}

	if len(helpFmt.Subcommands) > 0 {
		Logf(" <subcommand>")

		for _, subcmd := range helpFmt.Subcommands {
			if len(subcmd.Name) > maxLen {
				maxLen = len(subcmd.Name)
			}
		}
	}

	Logf("\n")

	if helpFmt.Description != "" {
		Logf("\n%s\n", helpFmt.Description)
	}

	if len(helpFmt.PositionalArgs) > 0 {
		Logf("\nPositional Arguments:\n")

		for _, posArg := range helpFmt.PositionalArgs {
			LogHelp(maxLen, posArg.Name, posArg.Help)
		}
	}

	if len(helpFmt.Subcommands) > 0 {
		Logf("\nSubcommands:\n")

		for _, subcmd := range helpFmt.Subcommands {
			LogHelp(maxLen, subcmd.Name, subcmd.Help)
		}
	}

	if hasOptions {
		Logf("\nOptions:\n")
		helpFmt.Flags.PrintDefaults()
	}
}

func (helpFmt HelpFormatter) HasAnyOptions() bool {
	hasOptions := false

	helpFmt.Flags.VisitAll(func(f *flag.Flag) {
		hasOptions = true
	})

	return hasOptions
}

func Logf(format string, args ...interface{}) {
	fmt.Fprintf(output, format, args...)
}

func LogHelp(maxLen int, name, help string) {
	Logf("  %-"+strconv.Itoa(maxLen)+"s  %s\n", name, help)
}

func Next(args []string) (arg string, tail []string) {
	if len(args) > 0 {
		return args[0], args[1:]
	}

	return "", args
}

func ExecSubcommand(flags *flag.FlagSet, subcmds []Subcommand, args []string) {
	cmd, args := Next(args)

	if cmd == "" {
		Logf("Expected subcommand.\n\n")
		flags.Usage()
		os.Exit(2)
	}

	for _, subcmd := range subcmds {
		if subcmd.Name == cmd {
			subcmd.Exec(args)
			return
		}
	}

	Logf("Unknown subcommand: %s\n\n", cmd)
	flags.Usage()
	os.Exit(2)
}

func ParseAllOptions(flags *flag.FlagSet, args []string) (posArgs []string) {
	for len(args) > 0 {
		if err := flags.Parse(args); err != nil {
			// Really you should just use ExitOnError rather than allow Parse()
			// to return an error
			panic(err)
		}

		args = flags.Args()

		for len(args) > 0 && !strings.HasPrefix(args[0], "-") {
			posArgs = append(posArgs, args[0])
			args = args[1:]
		}
	}

	return
}
endsnippet

pre_expand "add_import(snip, 'testing')"
snippet FailOnErrorOld "FailOnError Template (Old)" b
func FailOnError(t *testing.T) FailOnErrorT {
	return FailOnErrorT{T: t}
}

// A wrapper for *testing.T to stop the test on the first error
type FailOnErrorT struct {
	*testing.T
}

func (t FailOnErrorT) Errorf(format string, args ...interface{}) {
	t.T.Helper()
	t.T.Fatalf(format, args...)
}
endsnippet

pre_expand "add_import(snip, 'testing', 'sync')"
snippet FailOnError "FailOnError Template" b
func FailOnError(t *testing.T) *FailOnErrorT {
	return &FailOnErrorT{
		T: t,
		C: make(chan struct{}),
	}
}

// A wrapper for *testing.T to stop the test on the first error
type FailOnErrorT struct {
	*testing.T
	failOnce sync.Once
	C chan struct{}
}

func (t *FailOnErrorT) Errorf(format string, args ...interface{}) {
	t.T.Helper()
	t.failOnce.Do(func() {
		close(t.C)
	})
	t.T.Fatalf(format, args...)
}
endsnippet

pre_expand "add_import(snip, 'flag', 'fmt', 'os')"
snippet mainargs "Main with Argument Parsing" b
func main() {
	flags := flag.NewFlagSet(os.Args[0], flag.ExitOnError)

	subcmds := []Subcommand{
	}

	flags.Usage = HelpFormatter{
		Flags:       flags,
		Subcommands: subcmds,
	}.PrintUsage

	flags.Parse(os.Args[1:])

	args := flags.Args()

	ExecSubcommand(flags, subcmds, args)
}
endsnippet

pre_expand "add_import(snip, 'flag')"
snippet subcmd "Subcommand" b
func create$1Subcmd(parent *flag.FlagSet) Subcommand {
	name := "`!p snip.rv = t[1].lower()`"

	flags := flag.NewFlagSet(parent.Name()+" "+name, flag.ExitOnError)
	flags.SetOutput(parent.Output())

	subcmds := []Subcommand{
	}

	flags.Usage = HelpFormatter{
		Flags:          flags,
		Subcommands:    subcmds,
		PositionalArgs: []PosArg{
			{Name: "EXAMPLE", Help: "An example positional argument"},
		},
	}.PrintUsage

	return Subcommand{
		Name: name,
		Help: "TODO: Help",
		Exec: func(args []string) {
			flags.Parse(args)

			$0
		},
	}
}
endsnippet

snippet testmain "Main for Test Runner" b
import (
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"os"
	"testing"
)

func TestMain(m *testing.M) {
	log.Logger = log.Output(zerolog.ConsoleWriter{
		Out:        os.Stderr,
		TimeFormat: "15:04:05",
	})
	zerolog.SetGlobalLevel(zerolog.TraceLevel)

	code := m.Run()

	os.Exit(code)
}
endsnippet

snippet genstatic "Generate Static File Server" b
package main

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"github.com/evanw/esbuild/pkg/api"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"
)

/* Create the following shell script and tweak as necessary:
 *
 * #!/bin/bash
 *
 * # Change to root of project (one level up)
 * cd "\`dirname "${BASH_SOURCE[0]}"\`/.."
 *
 * echo Generating web routes for static files
 *
 * rm -f internal/static/routes.go
 *
 * go run scripts/build-static.go web/ internal/static/routes.go \`cat version\`
 */

func main() {
	if len(os.Args) != 4 {
		fmt.Println("Usage: go run scripts/build-static.go <input dir> <output path> <version>")
		os.Exit(1)
		return
	}

	dev := os.Getenv("MODE") == "dev"

	dir := os.Args[1]
	routesPath := os.Args[2]
	version := os.Args[3]

	fmt.Printf("Building static files in %s\n", dir)

	allFiles, err := readAllFiles(dir)

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
		return
	}

	fileTypes := map[string]string{
		".html": "text/html",
		".js":   "text/javascript",
		".css":  "text/css",
		".svg":  "image/svg+xml",
	}

	files := make([]string, 0)

	for _, file := range allFiles {
		if mimeType := fileTypes[path.Ext(file)]; mimeType != "" {
			files = append(files, file)
		}
	}

	lines := make([]string, 0)

	lines = append(
		lines,
		"package static",
		"",
		"import (",
		"\t\"github.com/gin-gonic/gin\"",
		"\t\"net/http\"",
		")",
		"",
		"func Routes(router *gin.RouterGroup) {",
	)

	for _, file := range files {
		mimeType := fileTypes[path.Ext(file)]

		// TODO: Ignore dotfiles

		data, err := ioutil.ReadFile(path.Join(dir, file))

		if err != nil {
			fmt.Printf("Error while trying to read %s: %s\n", file, err)
			os.Exit(1)
			return
		}

		fmt.Printf("%s\n", file)

		lines = append(
			lines,
			"",
			fmt.Sprintf("\trouter.GET(\"/%s\", func(c *gin.Context) {", file),
			"\t\tc.Header(\"Content-Encoding\", \"gzip\")",
			fmt.Sprintf("\t\tc.Data(http.StatusOK, \"%s\", []byte{%s})", mimeType, formatData(gzipCompress(data))),
			"\t})",
		)
	}

	if !dev {
		bundle := buildBundle()
		lines = append(
			lines,
			"",
			"\trouter.GET(\"/bundle.js\", func(c *gin.Context) {",
			"\t\tc.Header(\"Content-Encoding\", \"gzip\")",
			fmt.Sprintf("\t\tc.Data(http.StatusOK, \"text/javascript\", []byte{%s})", formatData(gzipCompress(bundle))),
			"\t})",
		)
	}

	indexPage := generateIndex(dev, version)

	lines = append(
		lines,
		"}",
	)

	lines = append(
		lines,
		"",
		fmt.Sprintf("var DefaultPage = []byte{%s}", formatData(gzipCompress(indexPage))),
		"",
	)

	ioutil.WriteFile(routesPath, []byte(strings.Join(lines, "\n")), 0644)
}

func formatData(data []byte) string {
	base10Data := make([]string, 0, len(data))

	for _, b := range data {
		base10Data = append(base10Data, fmt.Sprintf("%d", b))
	}

	return strings.Join(base10Data, ", ")
}

func readAllFiles(dir string) ([]string, error) {
	files := make([]string, 0)
	items, err := ioutil.ReadDir(dir)

	if err != nil {
		return nil, fmt.Errorf("failed to read directory '%s': %s", dir, err)
	}

	for _, item := range items {
		if item.IsDir() {
			p := path.Join(dir, item.Name())
			dirFiles, err := readAllFiles(p)

			if err != nil {
				return nil, err
			}

			for _, dirFile := range dirFiles {
				files = append(files, path.Join(item.Name(), dirFile))
			}
		} else {
			files = append(files, item.Name())
		}
	}

	return files, nil
}

func gzipCompress(data []byte) []byte {
	compressed := &bytes.Buffer{}

	compressor, err := gzip.NewWriterLevel(compressed, gzip.BestCompression)

	if err != nil {
		panic(err)
	}

	compressor.Write(data)
	compressor.Close()

	return compressed.Bytes()
}

func generateIndex(development bool, version string) []byte {
	rootScript := \`  <script crossorigin type="module" src="/index.js"></script>\`

	if development {
		fmt.Println("\n\n===== BUILDING FOR DEVELOPMENT =====\n\n")
	} else {
		rootScript = \`  <script crossorigin type="module" src="/bundle.js"></script>\`
	}

	return []byte(strings.Join([]string{
		\`<!doctype html>\`,
		\`<html lang="en">\`,
		\`<head>\`,
		\`  <meta charset="utf-8">\`,
		\`  <title>TODO</title>\`,
		\`  <script>window.Version = '\` + version + \`';</script>\`,
		rootScript,
		\`  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0 user-scalable=no">\`,
		\`  <link href="/assets/bootstrap.min.css" rel="stylesheet">\`,
		\`  <link href="/assets/style.css" rel="stylesheet">\`,
		\`</head>\`,
		\`<body></body>\`,
		\`</html>\`,
	}, "\n"))
}

func buildBundle() []byte {
	absPath, err := filepath.Abs("web")
	if err != nil {
		panic(err)
	}

	var resolver = api.Plugin{
		Name: "resolver",
		Setup: func(build api.PluginBuild) {
			build.OnResolve(api.OnResolveOptions{Filter: \`.js$\`},
				func(args api.OnResolveArgs) (api.OnResolveResult, error) {
					var p string

					if filepath.IsAbs(args.Path) {
						p = filepath.Join(absPath, args.Path)
					} else {
						p = filepath.Join(args.ResolveDir, args.Path)
					}

					return api.OnResolveResult{
						Path: p,
					}, nil
				})
		},
	}

	// If this package isn't availabe, then just change the module name to
	// 'index.js' until you get this fixed
	result := api.Build(api.BuildOptions{
		EntryPointsAdvanced: []api.EntryPoint{
			{InputPath: "index.js", OutputPath: "bundle.js"},
		},
		AbsWorkingDir:     absPath,
		Bundle:            true,
		Plugins:           []api.Plugin{resolver},
		MinifyWhitespace:  true,
		MinifyIdentifiers: true,
		// MinifySyntax: true,
	})

	if len(result.Errors) > 0 {
		for _, err := range result.Errors {
			fmt.Printf("ERROR: %v\n", err)
		}

		panic("ERRORS")
	}

	for _, warn := range result.Warnings {
		fmt.Printf("WARN: %v\n", warn)
	}

	if len(result.OutputFiles) != 1 {
		panic(fmt.Sprintf("Incorrect number of output files: %d", len(result.OutputFiles)))
	}

	file := result.OutputFiles[0]

	return file.Contents
}
endsnippet


pre_expand "add_import(snip, 'github.com/gin-gonic/gin')"
snippet ginserver "Gin Server" b
func BuildServer() *gin.Engine {
	server := gin.New()

	$0

	return server
}
endsnippet

snippet staticroutes "Static Routes" b
static.Routes(server.Group("/"))

server.NoRoute(func(c *gin.Context) {
	if strings.Contains(c.Request.Header.Get("Accept"), "text/html") {
		c.Header("Content-Encoding", "gzip")
		c.Data(http.StatusOK, "text/html", static.DefaultPage)
	} else {
		c.Status(http.StatusNotFound)
	}
})
endsnippet
